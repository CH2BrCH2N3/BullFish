import os
import csv
import cv2 as cv
import numpy as np
import pandas as pd
from math import sqrt, cos
from statistics import median, stdev
from copy import copy, deepcopy
from traceback import print_exc
from BullFish_pkg.general import create_path, get_input, csvtodict, load_settings
from BullFish_pkg.math import pyth, cal_direction, cal_direction_change
from BullFish_pkg.cv_editing import get_rm, frame_rotate, frame_grc, frame_blur, max_entropy_threshold, sq_area
from BullFish_pkg.plot import errors_correct, curve, step, DF, results_df
import matplotlib.pyplot as plt
from BullFish_pkg.plot import plot_data

print('Welcome to BullFish. After recording your zebrafish videos, this program will analyze their locomotion.')
print('BullFish consists of 3 programs:')
print('- [v]ideosetup: The user will select the video segment and swimming area for tracking and analysis.')
print('                The selections will be saved as a csv file.')
print('                This program will run through each video in the folder and repeat the selection process.')
print('                For each video, the user can also state the angle for video rotation and area for')
print('                cropping to facilitate the tracking.')
print('- [t]racker: After videosetup, this program will automatically track the zebrafish and generate the')
print('             representative coordinates of the zebrafish in each frame for each video.')
print('             This can only be performed after the selections in videosetup have been saved.')
print('- [a]nalysis: After the representative coordinates have been generated by tracker, this program will')
print('              characterize individual episodes of movement and obtain the macro- and micro-parameters.')

while True:
    
    print('Enter 1 letter from (v,t,a) to run the program, others to exit:')
    program = input()
    
    if program == 'v':
        
        print('Running videosetup...')
        default_settings = {
            "video_start": -1,
            "video_end": -1,
            "rotate": 181,
            "crop_tlx": -1,
            "crop_tly": -1,
            "crop_x": -1,
            "crop_y": -1,
            "swimarea_tlx": -1,
            "swimarea_tly": -1,
            "swimarea_x": -1,
            "swimarea_y": -1,
            "check": 1,
            'downsampling': 1}
        settings = load_settings('videosetup', default_settings)
        
        for file in os.listdir('.'):
             
            filename = os.fsdecode(file)
            filename_split = os.path.splitext(filename)
            supported_formats = {'.avi', '.mp4'}
            if filename_split[1] not in supported_formats:
                continue
            video = cv.VideoCapture(filename)
            if not video.isOpened():
                print(filename + ' cannot be opened.')
                continue
            print('\nOpening ' + filename + ' ...')
            
            try:
                
                videoname = filename_split[0]
                path = './' + videoname
                create_path(path)
                
                x_original = int(video.get(cv.CAP_PROP_FRAME_WIDTH))
                y_original = int(video.get(cv.CAP_PROP_FRAME_HEIGHT))
                framenumber_original = int(video.get(cv.CAP_PROP_FRAME_COUNT))
                fps = video.get(cv.CAP_PROP_FPS) / settings['downsampling']
                
                create_metadata = True
                if os.path.exists(path + '/' + videoname + '_metadata.csv'):
                    while True:
                        response = input(videoname + '_metadata.csv' + ' already exists. Enter y to use the existing metadata. Enter o to overwrite the metadata.')
                        if response == 'y':        
                            create_metadata = False
                        elif response != 'o':
                            print('Try again')
                            continue
                        break
                
                if create_metadata:
                    
                    print('Creating metadata for ' + videoname + '...')
                    metadata = copy(settings)
                    
                    print('Now, choose the video segment for tracking. Be aware of the frame rate as you need to enter the frame numbers instead of the time.')
                    if settings['video_start'] == -1:
                        metadata['video_start'] = get_input(int, 'What is the starting frame?')
                    if settings['video_end'] == -1:
                        metadata['video_end'] = get_input(int, 'What is the ending frame?')
                    while True:
                        if metadata['video_end'] < framenumber_original and metadata['video_start'] < metadata['video_end']:
                            break
                        else:
                            print('Unacceptable range. Choose again.')
                            metadata['video_start'] = get_input(int, 'What is the starting frame?')
                            metadata['video_end'] = get_input(int, 'What is the ending frame?')
                    
                    video.set(cv.CAP_PROP_POS_FRAMES, metadata['video_start'])
                    ret, frame1 = video.read()
                    cv.imwrite(videoname + '_Frame1.png', frame1)
                    video.release()
                    print('The first frame of the selected video segment has been saved at the current directory.')
                    print('The following part is to set the parameters for rotating and cropping the video to prepare for tracking.')
                    
                    if settings['rotate'] == 181:
                        metadata['rotate'] = get_input(float, 'Enter the video rotation angle (clockwise, enter within -179.9 to 180):')
                    if settings['crop_tlx'] == -1:
                        metadata['crop_tlx'] = get_input(int, 'Enter the x-coordinate of the top-left corner of the cropping area:')
                    if settings['crop_tly'] == -1:
                        metadata['crop_tly'] = get_input(int, 'Enter the y-coordinate of the top-left corner of the cropping area:')
                    if settings['crop_x'] == -1:
                        metadata['crop_x'] = get_input(int, 'Enter the width (x) of the cropping area:')
                    if settings['crop_y'] == -1:
                        metadata['crop_y'] = get_input(int, 'Enter the height (y) of the cropping area:')
                    
                    while settings['check']:
                        try:
                            rm = get_rm(x_original, y_original, metadata['rotate'])
                            frame_t = frame_rotate(frame1, x_original, y_original, metadata['rotate'], rm)
                            crop_brx = metadata['crop_tlx'] + metadata['crop_x']
                            crop_bry = metadata['crop_tly'] + metadata['crop_y']
                            if metadata['crop_x'] != 0 and metadata['crop_y'] != 0:
                                frame_t = frame_t[metadata['crop_tly']:crop_bry, metadata['crop_tlx']:crop_brx]
                            cv.imwrite(videoname + '_edited_frame.png', frame_t)
                            if input('The rotated and cropped frame is saved. Enter f to carry on, others to change:') == 'f':
                                break
                        except Exception:
                            print('An error occurred when editing the frame. Change parameters.')
                            print_exc()
                        metadata['rotate'] = get_input(float, 'Enter the video rotation angle (clockwise, enter within -179.9 to 180):')
                        metadata['crop_tlx'] = get_input(int, 'Enter the x-coordinate of the top-left corner of the cropping area:')
                        metadata['crop_tly'] = get_input(int, 'Enter the y-coordinate of the top-left corner of the cropping area:')
                        metadata['crop_x'] = get_input(int, 'Enter the width (x) of the cropping area:')
                        metadata['crop_y'] = get_input(int, 'Enter the height (y) of the cropping area:')
                    
                    size = frame_t.shape
                    x_current = size[1]
                    y_current = size[0]
                    
                    if settings['swimarea_tlx'] == -1:
                        metadata['swimarea_tlx'] = get_input(int, 'Enter the x-coordinate of the top-left corner of the swimming area:')
                    if settings['swimarea_tly'] == -1:
                        metadata['swimarea_tly'] = get_input(int, 'Enter the y-coordinate of the top-left corner of the swimming area:')
                    if settings['swimarea_x'] == -1:
                        metadata['swimarea_x'] = get_input(int, 'Enter the width (x) of the swimming area:')
                    if settings['swimarea_y'] == -1:
                        metadata['swimarea_y'] = get_input(int, 'Enter the height (y) of the swimming area:')
                    
                    while settings['check']:
                        frame_l = deepcopy(frame_t)
                        cv.rectangle(frame_l, (metadata['swimarea_tlx'], metadata['swimarea_tly']), (metadata['swimarea_tlx'] + metadata['swimarea_x'], metadata['swimarea_tly'] + metadata['swimarea_y']), (0, 0, 255), 3)
                        cv.imwrite(videoname + '_labeled_frame.png', frame_l)
                        if input('The swimming area is labeled in a new figure. Enter f to carry on, others to change:') == 'f':
                            break
                        metadata['swimarea_tlx'] = get_input(int, 'Enter the x-coordinate of the top-left corner of the swimming area:')
                        metadata['swimarea_tly'] = get_input(int, 'Enter the y-coordinate of the top-left corner of the swimming area:')
                        metadata['swimarea_x'] = get_input(int, 'Enter the width (x) of the swimming area:')
                        metadata['swimarea_y'] = get_input(int, 'Enter the height (y) of the swimming area:')
                    
                    metadata.update({
                        'filename': filename,
                        'fps': fps,
                        'x_original': x_original,
                        'y_original': y_original,
                        'x_current': x_current,
                        'y_current': y_current})
                    with open(path + '/' + videoname + '_metadata.csv', 'w') as f:
                        for key in metadata:
                            f.write(key + ',' + str(metadata[key]) + '\n')
                    
            except Exception:
                
                print('An error occurred when setting up ' + filename + ' for tracking:')
                print_exc()
        
        print('videosetup finished.')
    
    elif program == 't':
        
        print('Running tracker...')
        
        default_settings = {
            "ksize": 5,
            "t_sampling_time": 0.2,
            "threshold1_reduction": 10,
            "save_edittedvideo": 0,
            "save_binaryvideo": "FFV1",
            "save_annotatedvideo": "MJPG",
            "spine_analysis": 1,
            "spine_points": 10,
            'fast_s1': 0,
            'find_s0': 0,
            "auto_bg": 1,
            "fish_cover_size": 1.5,
            "threshold2_reduction": 0,
            "s0_range": 1}
        settings = load_settings('tracker', default_settings)
        
        for file in os.listdir('.'):
                
            try:
                filename = os.fsdecode(file)
                filename_split = os.path.splitext(filename)
                supported_formats = {'.avi', '.mp4'}
                if filename_split[1] not in supported_formats:
                    continue
                video = cv.VideoCapture(filename)
                if not video.isOpened():
                    print(filename + ' cannot be opened.')
                    continue
                videoname = filename_split[0]
                path = './' + videoname
                if not os.path.isfile(path + '/' + videoname + '_metadata.csv'):
                    print('Metadata missing for ' + videoname)
                    continue
                print('\nProcessing ' + filename)
            except Exception:
                print('An error occurred when opening ' + videoname + ':')
                print_exc()
                continue
            
            try:
                metadata = csvtodict(path + '/' + videoname + '_metadata.csv')
            except Exception:
                print('An error occurred when accessing the metadata of ' + videoname + ':')
                print_exc()
                continue
            
            try:
                
                rm = get_rm(metadata['x_original'], metadata['y_original'], metadata['rotate'])
                
                l = (metadata['video_end'] - metadata['video_start']) // metadata['downsampling']
                j = metadata['video_start']
                video.set(cv.CAP_PROP_POS_FRAMES, j)
                
                t_sampling = settings['t_sampling_time'] * metadata['fps'] * metadata['downsampling'] # calculate threshold once every how many frames
                threshold1s = np.zeros(l, dtype=np.int32)
                if settings['find_s0']:
                    threshold2s = np.zeros(l, dtype=np.int32)
                    leftmosts = [0 for i in range(l)]
                    rightmosts = [0 for i in range(l)]
                    topmosts = [0 for i in range(l)]
                    bottommosts = [0 for i in range(l)]
                    fish_perimeter2s = [] # impression of fish perimeter in t2
                    if not settings['auto_bg']:
                        print('Loading background...')
                        background = cv.imread(path + '/' + videoname + '_background.png')
                        background = cv.cvtColor(background, cv.COLOR_BGR2GRAY)
                            
                i = 0
                
                while j < metadata['video_end']:
                    
                    video.set(cv.CAP_PROP_POS_FRAMES, j)
                    ret, frame = video.read()
                    
                    if ret:
                        
                        frame_t = frame_grc(frame, metadata['x_original'], metadata['y_original'], metadata['rotate'], rm, metadata['crop_tlx'], metadata['crop_tly'], metadata['crop_x'], metadata['crop_y'])
                        frame_b = frame_blur(frame_t, settings['ksize'])
                        
                        threshold1s[i] = max_entropy_threshold(frame_b, settings['threshold1_reduction'])
                        ret, t1frame = cv.threshold(frame_b, threshold1s[i], 255, cv.THRESH_BINARY_INV)
                        
                        if settings['find_s0']:
                            contours, hierarchy = cv.findContours(t1frame, cv.RETR_LIST, cv.CHAIN_APPROX_NONE)
                            contour_number = len(contours)
                            max_perimeter = 0
                            for ii in range(contour_number):
                                contour_len = len(contours[ii])
                                if contour_len > max_perimeter:
                                    max_perimeter = contour_len
                                    fish_contour = contours[ii]
                            leftmost = tuple(fish_contour[fish_contour[:,:,0].argmin()][0])
                            rightmost = tuple(fish_contour[fish_contour[:,:,0].argmax()][0])
                            topmost = tuple(fish_contour[fish_contour[:,:,1].argmin()][0])
                            bottommost = tuple(fish_contour[fish_contour[:,:,1].argmax()][0])
                            leftmosts[i] = leftmost[0]
                            rightmosts[i] = rightmost[0]
                            topmosts[i] = topmost[1]
                            bottommosts[i] = bottommost[1]
                
                    else:
                    
                        break
            
                    print('\rt1_sampling progress: ', i, '/', l, end='')
                    j = round(j + t_sampling)
                    i = round(i + t_sampling)
                
                print()
                
                i = 1
                start = 0
                while i < l:
                    if threshold1s[i] != 0:
                        j = start + 1
                        while j < i:
                            threshold1s[j] = round((threshold1s[start] * (i - j) + threshold1s[i] * (j - start)) / (i - start))
                            j += 1
                        start = i
                    i += 1
                i = start
                while i < l:
                    threshold1s[i] = threshold1s[start]
                    i += 1
                
                if settings['find_s0']:
                    
                    if not settings['auto_bg']:
                        
                        print('Loading background...')
                        background = cv.imread(path + '/' + videoname + '_background.png')
                        background = cv.cvtColor(background, cv.COLOR_BGR2GRAY)
                        
                    else:
                        
                        print('Creating background...')
                        center_x0 = (leftmosts[0] + rightmosts[0]) / 2
                        center_y0 = (topmosts[0] + bottommosts[0]) / 2
                        thickness0 = max(rightmosts[0] - leftmosts[0], bottommosts[0] - topmosts[0]) * settings['fish_cover_size'] / 2
                        half_x0 = (rightmosts[0] - leftmosts[0]) / 2 + thickness0
                        half_y0 = (bottommosts[0] - topmosts[0]) / 2 + thickness0
                        left_boundary0 = round(center_x0 - half_x0)
                        right_boundary0 = round(center_x0 + half_x0)
                        top_boundary0 = round(center_y0 - half_y0)
                        bottom_boundary0 = round(center_y0 + half_y0)
                        
                        i = round(t_sampling)
                        background_frame = i
                        while i < l:
                            center_x = (leftmosts[i] + rightmosts[i]) / 2
                            center_y = (topmosts[i] + bottommosts[i]) / 2
                            thickness = max(rightmosts[i] - leftmosts[i], bottommosts[i] - topmosts[i]) * settings['fish_cover_size'] / 2
                            half_x = (rightmosts[i] - leftmosts[i]) / 2 + thickness
                            half_y = (bottommosts[i] - topmosts[i]) / 2 + thickness
                            left_boundary = round(center_x - half_x)
                            right_boundary = round(center_x + half_x)
                            top_boundary = round(center_y - half_y)
                            bottom_boundary = round(center_y + half_y)
                            bool_x = (left_boundary > right_boundary0) or (right_boundary < left_boundary0)
                            bool_y = (bottom_boundary < top_boundary0) or (top_boundary > bottom_boundary0)
                            if bool_x or bool_y:
                                background_frame = i
                                break
                            else:
                                i = round(i + t_sampling)
                        
                        video.set(cv.CAP_PROP_POS_FRAMES, metadata['video_start'])
                        ret, frame0 = video.read()
                        background = frame_grc(frame0, metadata['x_original'], metadata['y_original'], metadata['rotate'], rm, metadata['crop_tlx'], metadata['crop_tly'], metadata['crop_x'], metadata['crop_y'])
                        
                        video.set(cv.CAP_PROP_POS_FRAMES, metadata['video_start'] + background_frame)
                        ret, framei = video.read()
                        framei = frame_grc(framei, metadata['x_original'], metadata['y_original'], metadata['rotate'], rm, metadata['crop_tlx'], metadata['crop_tly'], metadata['crop_x'], metadata['crop_y'])
                        
                        for ii in range(top_boundary0, bottom_boundary0 + 1):
                            for jj in range(left_boundary0, right_boundary0 + 1):
                                try:
                                    background[ii][jj] = framei[ii][jj]
                                except:
                                    pass
                        print('Background created with frames ' + str(metadata['video_start']) + ' and ' + str(metadata['video_start'] + background_frame))
                        cv.imwrite(path + '/' + videoname + '_0.png', frame0)
                        cv.imwrite(path + '/' + videoname + '_i.png', framei)
                        cv.imwrite(path + '/' + videoname + '_background.png', background)
                        print(videoname + '_background.png' + ' saved.')
                    
                    i = 0
                    j = metadata['video_start']
                    
                    while j < metadata['video_end']:
                        
                        video.set(cv.CAP_PROP_POS_FRAMES, j)
                        ret, frame = video.read()
                        
                        if ret:
                            
                            frame_t = frame_grc(frame, metadata['x_original'], metadata['y_original'], metadata['rotate'], rm, metadata['crop_tlx'], metadata['crop_tly'], metadata['crop_x'], metadata['crop_y'])
                            frame_d = 255 - cv.absdiff(frame_t, background)
                            frame_db = frame_blur(frame_d, settings['ksize'])
                            threshold2s[i] = max_entropy_threshold(frame_db, settings['threshold2_reduction'])
                            
                            ret, t2frame = cv.threshold(frame_db, threshold2s[i], 255, cv.THRESH_BINARY_INV)
                            contours, hierarchy = cv.findContours(t2frame, cv.RETR_LIST, cv.CHAIN_APPROX_NONE)
                            fish_perimeter2s.append(max([len(contour) for contour in contours]))
                            
                        else:
                        
                            break
                
                        print('\rt2_sampling progress: ', i, '/', l, end='')
                        j = round(j + t_sampling)
                        i = round(i + t_sampling)
                    
                    print()
                
                    i = 1
                    start = 0
                    while i < l:
                        if threshold2s[i] != 0:
                            j = start + 1
                            while j < i:
                                threshold2s[j] = round((threshold2s[start] * (i - j) + threshold2s[i] * (j - start)) / (i - start))
                                j += 1
                            start = i
                        i += 1
                    i = start
                    while i < l:
                        threshold2s[i] = threshold2s[start]
                        i += 1
                
            except Exception:
                print_exc()
                continue
                
            try:
                
                if settings['save_edittedvideo']:
                    c = settings['save_edittedvideo']
                    edited = cv.VideoWriter(path + '/' + videoname + '_n.avi', cv.VideoWriter_fourcc(c[0], c[1], c[2], c[3]), metadata['fps'], (metadata['x_current'], metadata['y_current']), 0)
                if settings['save_binaryvideo']:
                    c = settings['save_binaryvideo']
                    binary1 = cv.VideoWriter(path + '/' + videoname + '_t1.avi', cv.VideoWriter_fourcc(c[0], c[1], c[2], c[3]), metadata['fps'], (metadata['x_current'], metadata['y_current']), 0)
                    if settings['find_s0']:
                        binary2 = cv.VideoWriter(path + '/' + videoname + '_t2.avi', cv.VideoWriter_fourcc(c[0], c[1], c[2], c[3]), metadata['fps'], (metadata['x_current'], metadata['y_current']), 0)
                if settings['save_annotatedvideo']:
                    c = settings['save_annotatedvideo']
                    annotated = cv.VideoWriter(path + '/' + videoname + '_a.avi', cv.VideoWriter_fourcc(c[0], c[1], c[2], c[3]), metadata['fps'], (metadata['x_current'], metadata['y_current']))
                    
                i = 0
                cen = np.zeros((l, 2))
                spine_len = settings['spine_points']
                spines = np.zeros((l, spine_len, 2))
                fish_perimeters = np.zeros(l, dtype=np.int32)
                heads = np.zeros((l, 2), dtype=np.int32)
                s0s = np.zeros((l, 2), dtype=np.int32)
                errors = {
                    'fish_not_found': [],
                    's0_not_found': []
                    }
                
                video.set(cv.CAP_PROP_POS_FRAMES, metadata['video_start'])
                i = 0
                j = metadata['video_start']
                
                while j < metadata['video_end']:
                    
                    ret, frame = video.read()
                    
                    if ret:
                    
                        frame_t = frame_grc(frame, metadata['x_original'], metadata['y_original'], metadata['rotate'], rm, metadata['crop_tlx'], metadata['crop_tly'], metadata['crop_x'], metadata['crop_y'])
                        if settings['save_edittedvideo']:
                            edited.write(frame_t)
                        
                        if settings['save_annotatedvideo']:
                            aframe = cv.cvtColor(frame_t, cv.COLOR_GRAY2BGR)
                        
                        frame_b = frame_blur(frame_t, settings['ksize'])
                        ret, t1frame = cv.threshold(frame_b, threshold1s[i], 255, cv.THRESH_BINARY_INV)
                        
                        contours1, hierarchy1 = cv.findContours(t1frame, cv.RETR_LIST, cv.CHAIN_APPROX_NONE)
                        contours1_number = len(contours1)
                        if contours1_number == 0:
                            errors['fish_not_found'].append(i)
                            continue
                        fish_perimeter1 = 0
                        for ii in range(contours1_number):
                            contour1_len = len(contours1[ii])
                            if contour1_len > fish_perimeter1:
                                fish_perimeter1 = contour1_len
                                fish_contour1 = contours1[ii]
                                fish_contour1_index = ii
                        fish_perimeters[i] = fish_perimeter1
                        
                        s1frame = np.zeros((metadata['y_current'], metadata['x_current']), dtype = np.uint8)
                        cv.drawContours(s1frame, contours1, fish_contour1_index, 255, -1)
                        if settings['save_binaryvideo']:
                            binary1.write(s1frame)
                        
                        moment = cv.moments(fish_contour1)
                        cen[i, 0] = moment['m10'] / moment['m00']
                        cen[i, 1] = moment['m01'] / moment['m00']
                        
                        if settings['spine_analysis']:
                            
                            sq_length = round(4 + cv.contourArea(fish_contour1) / 300)
                            s1_index = 0
                            min_fish_area = 99999999
                            
                            if settings['fast_s1']:
                                spacing = round(fish_perimeter1 / settings['fast_s1'])
                                contour1_points_sq = np.zeros((fish_perimeter1 - 1) // spacing, dtype=np.int32)
                                for ii in range(len(contour1_points_sq)):
                                    point = (fish_contour1[ii * spacing, 0, 0], fish_contour1[ii * spacing, 0, 1])
                                    contour1_points_sq[ii] = sq_area(s1frame, point, sq_length)
                                s1_index_t = np.argmin(contour1_points_sq)
                                if s1_index_t == 0:
                                    for ii in range(0, spacing):
                                        point = (fish_contour1[ii, 0, 0], fish_contour1[ii, 0, 1])
                                        fish_area = sq_area(s1frame, point, sq_length)
                                        if fish_area < min_fish_area:
                                            s1_index = ii
                                            min_fish_area = fish_area
                                    for ii in range(fish_perimeter1 - spacing, fish_perimeter1):
                                        point = (fish_contour1[ii, 0, 0], fish_contour1[ii, 0, 1])
                                        fish_area = sq_area(s1frame, point, sq_length)
                                        if fish_area < min_fish_area:
                                            s1_index = ii
                                            min_fish_area = fish_area
                                elif s1_index_t == fish_perimeter1 // spacing:
                                    for ii in range(fish_perimeter1 - spacing - fish_perimeter1 % spacing, fish_perimeter1):
                                        point = (fish_contour1[ii, 0, 0], fish_contour1[ii, 0, 1])
                                        fish_area = sq_area(s1frame, point, sq_length)
                                        if fish_area < min_fish_area:
                                            s1_index = ii
                                            min_fish_area = fish_area
                                    for ii in range(0, spacing):
                                        point = (fish_contour1[ii, 0, 0], fish_contour1[ii, 0, 1])
                                        fish_area = sq_area(s1frame, point, sq_length)
                                        if fish_area < min_fish_area:
                                            s1_index = ii
                                            min_fish_area = fish_area
                                else:
                                    for ii in range((s1_index_t - 1) * spacing, (s1_index_t + 1) * spacing):
                                        point = (fish_contour1[ii, 0, 0], fish_contour1[ii, 0, 1])
                                        fish_area = sq_area(s1frame, point, sq_length)
                                        if fish_area < min_fish_area:
                                            s1_index = ii
                                            min_fish_area = fish_area
                            else:
                                contour1_points_sq = np.zeros(fish_perimeter1, dtype=np.int32)
                                for ii in range(fish_perimeter1):
                                    point = (fish_contour1[ii, 0, 0], fish_contour1[ii, 0, 1])
                                    contour1_points_sq[ii] = sq_area(s1frame, point, sq_length)
                                    if contour1_points_sq[ii] < min_fish_area:
                                        s1_index = ii
                                        min_fish_area = contour1_points_sq[ii]
                            
                            fish_contour1_points = np.zeros((fish_perimeter1, 2), dtype=np.int32)    
                            jj = s1_index
                            ii = 0
                            while ii < fish_perimeter1:
                                fish_contour1_points[ii, 0] = fish_contour1[jj, 0, 0]
                                fish_contour1_points[ii, 1] = fish_contour1[jj, 0, 1]
                                jj += 1
                                ii += 1
                                if jj >= fish_perimeter1:
                                    jj -= fish_perimeter1
                            
                            min_head_pos = []
                            head_areas = []
                            for ii in range(fish_perimeter1 // 4, fish_perimeter1 * 3 // 4, 2):
                                head_areas.append(sq_area(s1frame, (fish_contour1_points[ii, 0], fish_contour1_points[ii, 1]), sq_length))
                            head_area_cutoff = round(np.percentile(head_areas, 20))
                            for ii in range(len(head_areas)):
                                if head_areas[ii] <= head_area_cutoff:
                                    min_head_pos.append(ii)
                            head_index = fish_perimeter1 // 4 + round(np.percentile(min_head_pos, 50)) * 2
                            heads[i, 0] = fish_contour1_points[head_index, 0]
                            heads[i, 1] = fish_contour1_points[head_index, 1]
                            
                            spines[i, 0, 0] = fish_contour1_points[0, 0]
                            spines[i, 0, 1] = fish_contour1_points[0, 1]
                            if head_index < fish_perimeter1 - head_index:
                                smaller_arc = head_index - 1
                                larger_arc = fish_perimeter1 - head_index - 1
                                for ii in range(1, spine_len):
                                    current_pos = round(smaller_arc * ii / spine_len)
                                    cor_pos = fish_perimeter1 - round(larger_arc * ii / spine_len)
                                    spines[i, ii, 0] = (fish_contour1_points[current_pos, 0] + fish_contour1_points[cor_pos, 0]) / 2
                                    spines[i, ii, 1] = (fish_contour1_points[current_pos, 1] + fish_contour1_points[cor_pos, 1]) / 2
                            else:
                                smaller_arc = fish_perimeter1 - head_index - 1
                                larger_arc = head_index - 1
                                for ii in range(1, spine_len):
                                    current_pos = round(fish_perimeter1 - smaller_arc * ii / spine_len)
                                    cor_pos = round(larger_arc * ii / spine_len)
                                    spines[i, ii, 0] = (fish_contour1_points[current_pos, 0] + fish_contour1_points[cor_pos, 0]) / 2
                                    spines[i, ii, 1] = (fish_contour1_points[current_pos, 1] + fish_contour1_points[cor_pos, 1]) / 2
                            
                            if settings['find_s0']:
                                
                                midpos = spine_len // 2
                                fish_perimeter2_est = median(fish_perimeter2s)
                                frame_d = 255 - cv.absdiff(frame_t, background)
                                frame_db = frame_blur(frame_d, settings['ksize'])
                                
                                for jj in range(threshold2s[i], 0, -1):
                                    
                                    ret, t2frame = cv.threshold(frame_db, jj, 255, cv.THRESH_BINARY_INV)
                                    
                                    contours2, hierarchy2 = cv.findContours(t2frame, cv.RETR_LIST, cv.CHAIN_APPROX_NONE)
                                    contours2_number = len(contours2)
                                
                                    if contours2_number == 0:
                                        
                                        errors['s0_not_found'].append(i)
                                        s0s[i, 0] = spines[i, 0, 0]
                                        s0s[i, 1] = spines[i, 0, 1]
                                        break
                                
                                    else:
                                        
                                        fish_contour2 = contours2[0]
                                        fish_contour2_index = 0
                                        fish_perimeter2 = len(fish_contour2)
                                        for ii in range(contours2_number):
                                            if cv.pointPolygonTest(contours2[ii], (spines[i, midpos, 0], spines[i, midpos, 1]), False) > 0:
                                                fish_contour2 = contours2[ii]
                                                fish_contour2_index = ii
                                                fish_perimeter2 = len(fish_contour2)
                                                break
                                        
                                        if fish_perimeter2 > fish_perimeter2_est * 3:
                                            continue
                                        
                                        s2frame = np.zeros((metadata['y_current'], metadata['x_current']), dtype = np.uint8)
                                        cv.drawContours(s2frame, contours2, fish_contour2_index, 255, -1)
                                        if settings['save_binaryvideo']:
                                            binary2.write(s2frame)
                                    
                                        dir_s1_to_s2 = cal_direction((spines[i, 0, 0], spines[i, 0, 1]), (spines[i, 1, 0], spines[i, 1, 1]))
                                        s0_choices = []
                                        for ii in range(fish_perimeter2):
                                            s0 = (fish_contour2[ii, 0, 0], fish_contour2[ii, 0, 1])
                                            dir_s0_to_s1 = cal_direction(s0, (spines[i, 0, 0], spines[i, 0, 1]))
                                            deviation = abs(cal_direction_change(dir_s0_to_s1, dir_s1_to_s2))
                                            if deviation < settings['s0_range']:
                                                s0_choices.append(s0)
                                        s0_number = len(s0_choices)
                                        
                                        if s0_number == 0:
                                            s0s[i, 0] = spines[i, 0, 0]
                                            s0s[i, 1] = spines[i, 0, 1]
                                        else:
                                            s0_area = 9999999
                                            for ii in range(s0_number):
                                                point_area = sq_area(s2frame, s0_choices[ii], sq_length)
                                                if point_area < s0_area:
                                                    s0_area = point_area
                                                    s0 = s0_choices[ii]
                                            s0s[i, 0] = s0[0]
                                            s0s[i, 1] = s0[1]
                                        
                                        threshold2s[i] = jj
                                        break
                        
                        if settings['save_annotatedvideo']:
                            cv.circle(aframe, (int(cen[i, 0]), int(cen[i, 1])), 3, (0, 255, 255), -1)
                            if settings['spine_analysis']:
                                for ii in range(fish_perimeter1):
                                    colorn = int(ii / fish_perimeter1 * 255)
                                    cv.circle(aframe, (round(fish_contour1_points[ii, 0]), round(fish_contour1_points[ii, 1])), 1, (0, colorn, 255 - colorn), -1)
                                for ii in range(spine_len):
                                    colorn = int(ii / spine_len * 255)
                                    cv.circle(aframe, (round(spines[i, ii, 0]), round(spines[i, ii, 1])), 2, (colorn, 255 - colorn // 2, 255 - colorn), -1)
                                heads[i] = fish_contour1_points[head_index]
                                cv.circle(aframe, (round(heads[i, 0]), round(heads[i, 1])), 3, (255, 0, 127), -1)
                                if settings['find_s0']:
                                    cv.circle(aframe, (round(s0s[i, 0]), round(s0s[i, 1])), 3, (255, 0, 255), -1)
                            annotated.write(aframe)
                    
                    else:
                        
                        break
                    
                    print('\rProgress: ', i, '/', l, end='')
                    j += metadata['downsampling']
                    i += 1
                
                print()
                video.release()
                if settings['save_edittedvideo']:
                    edited.release()
                if settings['save_binaryvideo']:
                    binary1.release()
                    if settings['find_s0']:
                        binary2.release() 
                if settings['save_annotatedvideo']:
                    annotated.release()
                
                metadata.update(settings)
                with open(path + '/' + videoname + '_metadata.csv', 'w') as f:
                    for key in metadata.keys():
                        f.write(key + ',' + str(metadata[key]) + '\n')
                
                with open(path + '/' + videoname + '_trackdata.csv', 'w', newline='') as f:
                    if settings['find_s0']:
                        fieldnames = ['threshold1', 'fish_perimeter', 'leftmost', 'rightmost', 'topmost', 'bottommost', 'threshold2']
                        writer = csv.DictWriter(f, fieldnames=fieldnames)
                        writer.writeheader()
                        for i in range(l):
                            writer.writerow({'threshold1': threshold1s[i],
                                             'fish_perimeter': fish_perimeters[i],
                                             'leftmost': leftmosts[i],
                                             'rightmost': rightmosts[i],
                                             'topmost': topmosts[i],
                                             'bottommost': bottommosts[i],
                                             'threshold2': threshold2s[i]})
                    else:
                        fieldnames = ['threshold1', 'fish_perimeter']
                        writer = csv.DictWriter(f, fieldnames=fieldnames)
                        writer.writeheader()
                        for i in range(l):
                            writer.writerow({'threshold1': threshold1s[i],
                                             'fish_perimeter': fish_perimeters[i]})
                if settings['find_s0']:
                    with open(path + '/' + videoname + '_fish_perimeter2_est.txt', 'w') as f:
                        f.write(str(fish_perimeter2_est))
                
                with open(path + '/' + videoname + '_cen.csv', 'w') as f:
                    header = ['centroidX', 'centroidY']
                    for word in header:
                        f.write(str(word) + ',')
                    f.write('\n')
                    for i in range(l):
                        row = [cen[i, 0], cen[i, 1]]
                        for cell in row:
                            f.write(str(cell) + ',')
                        f.write('\n')
                
                if settings['spine_analysis']:
                    
                    with open(path + '/' + videoname + '_errors.csv', 'w') as f:
                        for key in errors.keys():
                            f.write(key + ',')
                            for item in errors[key]:
                                f.write(str(item) + ',')
                            f.write('\n')
                    
                    with open(path + '/' + videoname + '_spine.csv', 'w') as f:
                        f.write('Spine points(XY\, XY\, ...)' + '\n')
                        for i in range(l):
                            row = []
                            for j in range(spine_len):
                                row.append(spines[i, j, 0])
                                row.append(spines[i, j, 1])
                            for cell in row:
                                f.write(str(cell) + ',')
                            f.write('\n')
                    
                    with open(path + '/' + videoname + '_sn+1s.csv', 'w') as f:
                        header = ['sn+1_x', 'sn+1_y']
                        for word in header:
                            f.write(str(word) + ',')
                        f.write('\n')
                        for i in range(l):
                            row = [heads[i, 0], heads[i, 1]]
                            for cell in row:
                                f.write(str(cell) + ',')
                            f.write('\n')
                    
                    if settings['find_s0']:
                        with open(path + '/' + videoname + '_s0s.csv', 'w') as f:
                            header = ['s0_x', 's0_y']
                            for word in header:
                                f.write(str(word) + ',')
                            f.write('\n')
                            for i in range(l):
                                row = [s0s[i, 0], s0s[i, 1]]
                                for cell in row:
                                    f.write(str(cell) + ',')
                                f.write('\n')
                    
                print('Tracking of ' + videoname + ' complete.')
                
            except Exception:
                
                print('An error occurred when processing ' + videoname + ':')
                print_exc()
                continue
        
        print('tracker finished.')
        
    elif program == 'a':
        
        print('Running analysis...')
        
        default_settings = {
            "tank_x": 210,
            "tank_y": 144,
            "plot_figure": 0,
            "sampling": 2,
            "speed_limit": 2000,
            'analysis_extended': 0,
            "accel_cutoff": 100,
            "min_accel_dur": 0.02,
            "min_max_accel": 100,
            "min_speed_change": 0,
            "spine_analysis": 1,
            'alternate_turn': 0,
            'use_s0': 0,
            'correct_errors': 0,
            'correction_window': 0.05,
            'max_turn': 1,
            "turn_cutoff": 2,
            "min_turn_dur": 0.02,
            "min_max_turn_velocity": 2,
            "min_turn_angle": 0.2,
            "bend_cutoff": 2,
            "min_bend_dur": 0.02,
            "min_bend_speed": 2,
            "min_bend_angle": 0.1,
            "min_amp": 2}
        settings = load_settings('analysis', default_settings)
        
        sampling = settings['sampling']
        videonames = []
        analyses = []
        analyses_df = pd.DataFrame()
        error2s_all = []
        fdirs_all = pd.DataFrame()
        angles_all = pd.DataFrame()
        steps_all = pd.DataFrame()
        first_video = True

        # search for videos in the current directory
        for file in os.listdir('.'):
            
            # check if the file is a video in the supported formats
            filename = os.fsdecode(file)
            filename_split = os.path.splitext(filename)
            supported_formats = {'.avi', '.mp4'}
            if filename_split[1] not in supported_formats:
                continue
            
            # check if the video has been tracked
            videoname = filename_split[0]
            path = './' + videoname
            if not os.path.isfile(path + '/' + videoname + '_metadata.csv'):
                print('Metadata missing for ' + videoname)
                continue
            videonames.append(videoname)
            
            # load metadata
            print('\nProcessing ' + filename)
            metadata = csvtodict(path + '/' + videoname + '_metadata.csv')
            l = metadata['video_end'] - metadata['video_start']
            if metadata['swimarea_x'] > metadata['swimarea_y']:
                ratio = settings['tank_x'] / metadata['swimarea_x']
            else:
                ratio = settings['tank_y'] / metadata['swimarea_y']
            fps = metadata['fps']
            
            # load essential tracking data
            with open(path + '/' + videoname + '_cen.csv', 'r') as f:
                cen = [[cell for cell in row] for row in csv.reader(f)]
                cen.pop(0)
                for i in range(l):
                    cen[i] = (float(cen[i][0]) * ratio, float(cen[i][1]) * ratio)
            
            # obtain a list of speed at each frame
            cen_dists = [0 for i in range(l)]
            speeds = [0 for i in range(l)]
            for i in range(sampling, l, sampling):
                cen_dists[i] = pyth(cen[i], cen[i - sampling]) / sampling
                speeds[i] = cen_dists[i] * fps
            for i in range(0, sampling):
                cen_dists[i] = cen_dists[sampling]
            for i in range(sampling * 2, l, sampling):
                for j in range(i - sampling + 1, i):
                    cen_dists[j] = (cen_dists[i - sampling] * (i - j) + cen_dists[i] * (j - (i - sampling))) / sampling
                    speeds[j] = cen_dists[j] * fps
            
            if settings['correct_errors']:
                error1_frames = []
                for i in range(l):
                    if speeds[i] > settings['speed_limit']:
                        error1_frames.append(i)
                cen_dists = errors_correct(cen_dists, error1_frames, l)
                speeds = errors_correct(speeds, error1_frames, l)
            
            # obtain total distance travelled and average speed
            total_distance = sum(cen_dists)
            total_time = l / fps
            speed_avg = total_distance / total_time
            
            # determine whether the fish is freezing for each frame
            freeze = [0 for i in range(l)]
            for i in range(int(fps * 3), l):
                cdist1 = pyth(cen[int(i - fps * 2)], cen[int(i - fps * 3)])
                cdist2 = pyth(cen[int(i - fps)], cen[int(i - fps * 2)])
                cdist3 = pyth(cen[i], cen[int(i - fps)])
                if cdist1 < 1 and cdist2 < 1 and cdist3 < 1:
                    for j in range(int(i - fps * 3 + 1), i + 1):
                        freeze[j] = 1
                elif cdist1 > 1 and cdist2 > 1 and cdist3 > 1:
                    for j in range(int(i - fps * 2 + 1), i + 1):
                        freeze[j] = 0
            
            # obtain parameters related to freezing
            total_freeze_time = sum(freeze) / fps
            freeze_percent = total_freeze_time / total_time * 100
            active_time = total_time - total_freeze_time
            active_speed = total_distance / active_time
            freeze_count = 0
            for i in range(2, l):
                if freeze[i] - freeze[i - 1] == 1:
                    freeze_count += 1
            freeze_freq = freeze_count * 60 / total_time
            
            # obtain a list of speeds with running average and obtain max speed
            speeds = curve(speeds, start=1, end=l, window=5)
            max_speed = max(speeds.list)
            
            # obtain a list of speed measured over 1s
            cdist1s = [0 for i in range(l)]
            for i in range(1, l):
                start = max(1, round(i + 1 - fps / 2))
                end = min(l, round(i + 1 + fps / 2))
                cdist1s[i] = sum([cen_dists[j] for j in range(start, end)]) * fps / (end - start)
            cdist1s[0] = cdist1s[1]
            max_distance_1s = max(cdist1s)
            
            ds_from_wall = [0 for i in range(l)]
            thigmotaxis_time = 0
            xl = metadata['swimarea_tlx'] * ratio
            length = metadata['swimarea_x'] * ratio
            xr = xl + length
            yt = metadata['swimarea_tly'] * ratio
            width = metadata['swimarea_y'] * ratio
            yb = yt + width
            d_from_wall = min(length, width) / 4
            for i in range(l):
                x = min(cen[i][0] - xl, xr - cen[i][0])
                y = min(cen[i][1] - yt, yb - cen[i][1])
                ds_from_wall[i] = min(x, y)
                if ds_from_wall[i] < d_from_wall:
                    thigmotaxis_time += 1
            thigmotaxis_time /= fps
            
            analysis = {
                'videoname': videoname,
                'total_time': total_time,
                'total_distance': total_distance,
                'speed_avg': speed_avg,
                'max_speed': max_speed,
                'max_distance_1s': max_distance_1s,
                'active_speed': active_speed,
                'freeze_percent': freeze_percent,
                'freeze_count': freeze_count,
                'freeze_freq': freeze_freq,
                'thigmotaxis_time': thigmotaxis_time}
            
            if settings['plot_figure']:
                create_path('Tracks')
                fig, ax = plt.subplots()
                ax.scatter(x=[cen[i][0] for i in range(l)], y=[cen[i][1] for i in range(l)])
                fig.savefig('Tracks/' + videoname + '_track.png')
                plt.close()
            
            speeds.dt(fps)
            speeds.get_p_dflns(settings['accel_cutoff'], -10, -20,
                               settings['min_accel_dur'], settings['min_max_accel'], settings['min_speed_change'])
            
            if speeds.p_dflns_count == 0:
                print('No detectable movement')
                if settings['save_individually']:
                    with open(path + '/' + videoname + '_analysis.csv', 'w') as f:
                        for key in analysis:
                            f.write(key + ',' + str(analysis[key]) + '\n')
                analyses.append(analysis)
                print('Analysis of ' + videoname + ' complete.')
                with open(path + '/' + videoname + '_analysis_notes.csv', 'w') as f:
                    for key in settings:
                        f.write(key + ', ' + str(settings[key]) + '\n')
                continue
            
            for i in range(speeds.p_dflns_count):
                speeds.p_dflns[i].dict.update({
                    'acceleration': speeds.p_dflns[i].maxslope,
                    'speed_change': speeds.p_dflns[i].change})
                speeds.p_dflns[i].env.update({
                    'speed': cdist1s[round(speeds.p_dflns[i].centralpos)]})
            
            if settings['plot_figure']:
                speeds.graph_dflns()
            
            if not settings['spine_analysis']:
                analyses.append(analysis)
                print('Analysis of ' + videoname + ' complete.')
                with open(path + '/' + videoname + '_analysis_notes.csv', 'w') as f:
                    for key in settings:
                        f.write(key + ', ' + str(settings[key]) + '\n')
                continue # step analysis when spine_analysis is disabled is not yet available
            
            # load midline points data
            spine_len = metadata['spine_points']
            spines = [[[0, 0] for j in range(spine_len)] for i in range(l)]
            with open(path + '/' + videoname + '_spine.csv', 'r') as f:
                spines_temp = [[cell for cell in row] for row in csv.reader(f)]
                spines_temp.pop(0)
                for i in range(l):
                    for j in range(spine_len):
                        spines[i][j][0] = float(spines_temp[i][j * 2]) * ratio
                        spines[i][j][1] = float(spines_temp[i][j * 2 + 1]) * ratio
            
            s0s = [[0, 0] for i in range(l)]
            if settings['use_s0']:
                with open(path + '/' + videoname + '_s0s.csv', 'r') as f:
                    s0s_temp = [[cell for cell in row] for row in csv.reader(f)]
                    s0s_temp.pop(0)
                    for i in range(l):
                        s0s[i][0] = float(s0s_temp[i][0]) * ratio
                        s0s[i][1] = float(s0s_temp[i][1]) * ratio
            
            error2_pts = []
            dirs_nn = [0 for i in range(l)]
            for i in range(l):
                dirs_nn[i] = cal_direction(spines[i][spine_len - 2], spines[i][spine_len - 1])
            turns_nn = [0 for i in range(l)]
            for i in range(1, l):
                turns_nn[i] = cal_direction_change(dirs_nn[i - 1], dirs_nn[i])
            dirs_12 = [0 for i in range(l)]
            for i in range(l):
                dirs_12[i] = cal_direction(spines[i][0], spines[i][1])
            turns_12 = [0 for i in range(l)]
            for i in range(1, l):
                turns_12[i] = cal_direction_change(dirs_12[i - 1], dirs_12[i])
            #stds = [0 for i in range(l)]
            for i in range(1, l):
                #stds[i] = stdev([pyth(spines[i - 1][j], spines[i][j]) for j in range(spine_len)])
                if abs(turns_nn[i]) > settings['max_turn'] or abs(turns_12[i]) > settings['max_turn']:
                    error2_pts.append(i)
            
            error2_count = 0
            error2_pt_count = len(error2_pts)
            error2_intervals = []
            window = round(settings['correction_window'] * fps)
            i = 0
            while i < error2_pt_count - 1:
                if error2_pts[i + 1] - error2_pts[i] <= window:
                    error2_intervals.append([error2_pts[i], error2_pts[i + 1]])
                    error2_count += (error2_pts[i + 1] - error2_pts[i])
                    i += 1
                i += 1
            print(f'{error2_count} frames with abnormal midline points detected at intervals {error2_intervals}')
            
            if settings['correct_errors']:
                
                correct_frames_path = path + '/Corrected_frames'
                create_path(correct_frames_path)
                video_n = cv.VideoCapture(path + '/' + videoname + '_n.avi')
                for interval in error2_intervals:
                    i = interval[0] - 1
                    j = interval[1]
                    w = j - i
                    for ii in range(1, w):
                        for jj in range(spine_len):
                            spines[i + ii][jj][0] = (spines[i][jj][0] * (w - ii) + spines[j][jj][0] * ii) / w
                            spines[i + ii][jj][1] = (spines[i][jj][1] * (w - ii) + spines[j][jj][1] * ii) / w
                        s0s[i + ii][0] = float(spines[i + ii][0][0])
                        s0s[i + ii][1] = float(spines[i + ii][0][1])
                        video_n.set(cv.CAP_PROP_POS_FRAMES, i + ii)
                        ret, frame = video_n.read()
                        if ret:
                            for jj in range(spine_len):
                                colorn = int(jj / spine_len * 255)
                                cv.circle(frame, (round(spines[i + ii][jj][0] / ratio), round(spines[i + ii][jj][1] / ratio)), 3, (colorn, 255 - colorn // 2, 255 - colorn), -1)
                            cv.imwrite(correct_frames_path + '/' + str(i + ii) + '.png', frame)
                video_n.release()
                
                error2_pts_new = []
                dirs_nn_new = [0 for i in range(l)]
                for i in range(l):
                    dirs_nn_new[i] = cal_direction(spines[i][spine_len - 2], spines[i][spine_len - 1])
                turns_nn_new = [0 for i in range(l)]
                for i in range(1, l):
                    turns_nn_new[i] = cal_direction_change(dirs_nn_new[i - 1], dirs_nn_new[i])
                dirs_12_new = [0 for i in range(l)]
                for i in range(l):
                    dirs_12_new[i] = cal_direction(spines[i][0], spines[i][1])
                turns_12_new = [0 for i in range(l)]
                for i in range(1, l):
                    turns_12_new[i] = cal_direction_change(dirs_12_new[i - 1], dirs_12_new[i])
                for i in range(1, l):
                    if abs(turns_nn_new[i]) > settings['max_turn'] or abs(turns_12_new[i]) > settings['max_turn']:
                        error2_pts_new.append(i)
                
                error2_count_new = 0
                error2_pt_count_new = len(error2_pts_new)
                error2_intervals_new = []
                i = 0
                while i < error2_pt_count_new - 1:
                    if error2_pts_new[i + 1] - error2_pts_new[i] <= window:
                        error2_intervals_new.append([error2_pts_new[i], error2_pts_new[i + 1]])
                        error2_count_new += (error2_pts_new[i + 1] - error2_pts_new[i])
                        i += 1
                    i += 1
                print(f'{error2_count_new} frames remain at intervals {error2_intervals_new}')
                error2s_all.append({
                    'videoname': videoname,
                    'error2_count': error2_count,
                    'error2_count_new': error2_count_new})
                
                with open(path + '/' + videoname + '_error2s.csv', 'w') as f:
                    f.write('Frame,Turn_nn,Turn_nn_corrected,Turn_12,Turn_12_corrected\n')
                    for i in range(l):
                        f.write(f'{i},{turns_nn[i]},{turns_nn_new[i]},{turns_12[i]},{turns_12_new[i]}\n')
                
                with open(path + '/' + videoname + '_spine_corrected.csv', 'w') as f:
                    for i in range(l):
                        for j in range(spine_len):
                            f.write(f'{spines[i][j][0]},{spines[i][j][1]},')
                        f.write('\n')
                
            else:
                
                error2s_all.append({
                    'videoname': videoname,
                    'error2_count': error2_count})
                with open(path + '/' + videoname + '_error2s.csv', 'w') as f:
                    f.write('Frame,Turn_nn,Turn_12\n')
                    for i in range(l):
                        f.write(f'{i},{turns_nn[i]},{turns_12[i]}\n')
            
            directions = [0 for i in range(l)]
            for i in range(l):
                if settings['alternate_turn']:
                    directions[i] = cal_direction(spines[i][round(spine_len * 2 / 3)], spines[i][spine_len - 1])
                else:
                    directions[i] = cal_direction(spines[i][spine_len - 2], spines[i][spine_len - 1])
            turns = [0 for i in range(l)]
            for i in range(1, l):
                turns[i] = cal_direction_change(directions[i - 1], directions[i])
            
            spine_lens = [spine_len for i in range(l)]
            if settings['use_s0']:
                for i in range(l):
                    if abs(s0s[i][0] - spines[i][0][0]) >= 0.1 and abs(s0s[i][1] - spines[i][0][1]) >= 0.1:
                        spines[i].insert(0, [float(s0s[i][0]), float(s0s[i][1])])
                        spine_lens[i] += 1
            
            heads = [0 for i in range(l)]
            with open(path + '/' + videoname + '_sn+1s.csv', 'r') as f:
                temp = [[cell for cell in row] for row in csv.reader(f)]
                temp.pop(0)
                for i in range(l):
                    heads[i] = (float(temp[i][0]) * ratio, float(temp[i][1]) * ratio)
            
            # calculate bend angles, amps
            spine_angles = [[] for i in range(l)]
            angles = [0 for i in range(l)]
            for i in range(l):
                # calculate direction from one midline point to another, caudal to cranial
                spine_dirs = []
                for j in range(1, spine_lens[i]):
                    spine_dirs.append(cal_direction(spines[i][j - 1], spines[i][j]))
                # calculate bend angles. left is +, right is -
                for j in range(2, spine_lens[i]):
                    spine_angles[i].append(cal_direction_change(spine_dirs[j - 1], spine_dirs[j - 2]))
                    angles[i] += spine_angles[i][j - 2]
            
            amps = [0 for i in range(l)]
            trunk_amps = [[0 for j in range(spine_lens[i] - 2)] for i in range(l)]
            for i in range(l):
                if spines[i][spine_lens[i] - 1][0] == spines[i][spine_lens[i] - 2][0]:
                    for j in range(spine_lens[i] - 2):
                        trunk_amps[i][j] = abs(spines[i][j][0] - spines[i][spine_lens[i] - 1][0])
                else:
                    m = (spines[i][spine_lens[i] - 1][1] - spines[i][spine_lens[i] - 2][1]) / (spines[i][spine_lens[i] - 1][0] - spines[i][spine_lens[i] - 2][0])
                    c = spines[i][spine_lens[i] - 1][1] - m * spines[i][spine_lens[i] - 1][0]
                    for j in range(spine_lens[i] - 2):
                        trunk_amps[i][j] = abs(m * spines[i][j][0] - spines[i][j][1] + c) / sqrt(m ** 2 + 1)
                amps[i] = trunk_amps[i][0]
            
            fish_segs = [[0 for j in range(spine_lens[i])] for i in range(l)]
            for i in range(l):
                for j in range(spine_lens[i] - 1):
                    fish_segs[i][j] = pyth(spines[i][j], spines[i][j + 1])
                fish_segs[i][spine_lens[i] - 1] = pyth(spines[i][spine_lens[i] - 1], heads[i])
            fish_lengths = [sum(fish_segs[i]) for i in range(l)]
            bend_poss = [0 for i in range(l)]
            for i in range(l):
                for j in range(spine_lens[i] - 2):
                    if trunk_amps[i][j] < settings['min_amp']:
                        if j >= 1:
                            bend_poss[i] = sum(fish_segs[i][0:j]) / fish_lengths[i]
                        break
            bend_poss = curve(bend_poss, 0, l, 3)
            
            fish_length_med = float(pd.DataFrame(fish_lengths).median().iloc[0])
            analysis.update({'fish_length': fish_length_med})
            
            if settings['correct_errors']:
                error_frames = []
                with open(path + '/' + videoname + '_errors.csv', 'r') as f:
                    for row in csv.reader(f):
                        for cell in row:
                            if cell.isnumeric():
                                error_frames.append(int(cell))
                angles = errors_correct(angles, error_frames, l)
                amps = errors_correct(amps, error_frames, l)
            
            fdirs = [0 for i in range(l)] # fdirs is a list of special running average of direction of locomotion
            fdirs[0] = directions[0]
            for i in range(1, l):
                fdirs[i] = fdirs[i - 1] + turns[i]
            
            fdirs = curve(fdirs, start=0, end=l, window=3)
            fdirs.dt(fps) # turning left is -, turning right is +
            fdirs.get_p_dflns(settings['turn_cutoff'], 2, 2,
                              settings['min_turn_dur'], settings['min_max_turn_velocity'], settings['min_turn_angle'])
            fdirs.get_n_dflns(settings['turn_cutoff'], -2, -2,
                              settings['min_turn_dur'], settings['min_max_turn_velocity'], settings['min_turn_angle'])
            fdirs.merge_dflns()
            
            if settings['plot_figure']:
                fdirs.graph_dflns()
            
            for i in range(fdirs.dflns_count):
                fdirs.dflns[i].dict.update({
                    'turn_angle': abs(fdirs.dflns[i].change),
                    'turn_angular_velocity': abs(fdirs.dflns[i].maxslope),
                    'turn_duration': fdirs.dflns[i].dur,
                    'turn_laterality': 'left' if fdirs.dflns[i].change < 0 else 'right'})
                fdirs.dflns[i].env.update({'speed': cdist1s[round(fdirs.dflns[i].centralpos)]})
            
            angles = curve(angles, start=0, end=l, window=5)
            angles.dt(fps) # turning left is +, turning right is -
            angles.get_p_dflns(settings['bend_cutoff'], 2, 2,
                               settings['min_bend_dur'], settings['min_bend_speed'], settings['min_bend_angle'])
            angles.get_n_dflns(settings['bend_cutoff'], -2, -2,
                               settings['min_bend_dur'], settings['min_bend_speed'], settings['min_bend_angle'])
            angles.merge_dflns()
            '''
            if settings['plot_figure']:
                angles.graph_dflns()
            '''
            angles_neutral = copy(angles.list)
            angles_neutral_count = l
            for d in angles.p_dflns:
                for i in range(d.startpos, d.endpos + 1):
                    angles_neutral[i] = 0
                    angles_neutral_count -= 1
            for d in angles.n_dflns:
                for i in range(d.startpos, d.endpos + 1):
                    angles_neutral[i] = 0
                    angles_neutral_count -= 1
            angle_neutral = sum(angles_neutral) / angles_neutral_count
            analysis.update({'angle_neutral': angle_neutral})
            
            for i in range(angles.dflns_count):
                angles.dflns[i].dict.update({
                    'angle_change': abs(angles.dflns[i].change),
                    'angle start': angles.dflns[i].startval,
                    'angle end': angles.dflns[i].endval,
                    'bend_dur': angles.dflns[i].dur,
                    'bend_angular_velocity': angles.dflns[i].maxslope,
                    'bend_pos': max(bend_poss.list[angles.dflns[i].startpos:(angles.dflns[i].endpos + 1)])})
                if angles.dflns[i].change > 0:
                    angles.dflns[i].dict.update({'bend_laterality': 'left'})
                    if angles.dflns[i].startval * 0.2 + angles.dflns[i].endval * 0.8 > angle_neutral:
                        angles.dflns[i].dict.update({'recoil': False})
                    else:
                        angles.dflns[i].dict.update({'recoil': True})
                else:
                    angles.dflns[i].dict.update({'bend_laterality': 'right'})
                    if angles.dflns[i].startval * 0.2 + angles.dflns[i].endval * 0.8 < angle_neutral:
                        angles.dflns[i].dict.update({'recoil': False})
                    else:
                        angles.dflns[i].dict.update({'recoil': True})
                angles.dflns[i].env.update({'speed': cdist1s[round(angles.dflns[i].centralpos)]})
            
            analysis_df = results_df(pd.DataFrame())
            if settings['analysis_extended']:
                agg1 = ['sum', 'mean', 'std', 'median', 'p5', 'p95', 'ipr']
                agg2 = ['mean', 'std', 'median', 'p5', 'p95', 'ipr']
                agg3 = ['median', 'p5', 'p95', 'ipr']
            else:
                agg1 = ['sum', 'mean']
                agg2 = ['mean']
                agg3 = ['median']
            
            speeds_df = [d.dict for d in speeds.p_dflns]
            for i in range(speeds.p_dflns_count):
                speeds_df[i].update(speeds.p_dflns[i].env)
            speeds_df = pd.DataFrame(speeds_df)
            speeds_methods = {'acceleration': agg2,
                              'speed_change': agg1}
            speeds_DF = DF(speeds_df, 'acceleration', speeds_methods.keys())
            analysis_df.add(speeds_DF.agg(speeds_methods))
            analysis_df.add(speeds_DF.stratify1('speed'))
            
            fdirs_df = [d.dict for d in fdirs.dflns]
            for i in range(fdirs.dflns_count):
                fdirs_df[i].update(fdirs.dflns[i].env)
                fdirs_df[i].update({'centralpos': fdirs.dflns[i].centralpos})
            fdirs_df = pd.DataFrame(fdirs_df)
            fdirs_methods = {'turn_angle': agg1,
                             'turn_angular_velocity': agg2,
                             'turn_duration': agg1}
            fdirs_DF = DF(fdirs_df, 'turn', fdirs_methods.keys())
            fdirs_DF.dfs.update({
                'turn left': fdirs_df[fdirs_df['turn_laterality'] == 'left'],
                'turn right': fdirs_df[fdirs_df['turn_laterality'] == 'right']})
            analysis_df.add(fdirs_DF.agg(fdirs_methods))
            analysis_df.add(fdirs_DF.agg(fdirs_methods, 'turn left'))
            analysis_df.add(fdirs_DF.agg(fdirs_methods, 'turn right'))
            analysis_df.add(fdirs_DF.stratify1('speed'))
            analysis_df.add(fdirs_DF.stratify2('turn left', 'turn right', 'speed'))
            
            total_turn_angle = analysis_df.df.loc[(analysis_df.df['Type'] == 'turn') &
                                                  analysis_df.df['Classify'].isna() &
                                                  (analysis_df.df['Parameter'] == 'turn_angle') &
                                                  (analysis_df.df['Method'] == 'sum'), 'Value']
            analysis.update({'meandering': total_turn_angle.iloc[0] / total_distance})
            
            angles_df = [d.dict for d in angles.dflns]
            for i in range(angles.dflns_count):
                angles_df[i].update(angles.dflns[i].env)
                angles_df[i].update({'centralpos': angles.dflns[i].centralpos})
            angles_df = pd.DataFrame(angles_df)
            angles_methods = {'angle_change': agg1,
                              'bend_dur': agg1,
                              'bend_pos': agg2,
                              'bend_angular_velocity': agg2}
            angles_DF = DF(angles_df, 'bend', angles_methods.keys())
            angles_DF.dfs.update({
                'bend left': angles_df[angles_df['bend_laterality'] == 'left'],
                'bend right': angles_df[angles_df['bend_laterality'] == 'right']})
            analysis_df.add(angles_DF.agg(angles_methods))
            analysis_df.add(angles_DF.agg(angles_methods, 'bend left'))
            analysis_df.add(angles_DF.agg(angles_methods, 'bend right'))
            analysis_df.add(angles_DF.stratify1('speed'))
            analysis_df.add(angles_DF.stratify2('bend left', 'bend right', 'speed'))
            
            recoils_df = angles_df[angles_df['recoil'] == True]
            recoils_DF = DF(recoils_df, 'recoil', angles_methods.keys())
            recoils_DF.dfs.update({
                'bend left': recoils_df[recoils_df['bend_laterality'] == 'left'],
                'bend right': recoils_df[recoils_df['bend_laterality'] == 'right']})
            analysis_df.add(recoils_DF.agg(angles_methods))
            analysis_df.add(recoils_DF.agg(angles_methods, 'bend left'))
            analysis_df.add(recoils_DF.agg(angles_methods, 'bend right'))
            analysis_df.add(recoils_DF.stratify1('speed'))
            analysis_df.add(recoils_DF.stratify2('bend left', 'bend right', 'speed'))
            
            steps = []
            
            for i in range(speeds.p_dflns_count):
                
                candidates = []
                scores = []
                for j in range(angles.dflns_count):
                    if angles.dflns[j].belong == -1 and not angles.dflns[j].dict['recoil']:
                        if angles.dflns[j].endpos >= speeds.p_dflns[i].startpos and angles.dflns[j].startpos <= speeds.p_dflns[i].endpos:
                            candidates.append(j)
                            scores.append(abs(angles.dflns[j].centralpos - speeds.p_dflns[i].centralpos))
                
                if len(candidates) == 0:
                    continue
                
                choice = candidates[scores.index(min(scores))]
                s = step()
                s.accel = speeds.p_dflns[i]
                s.bends.append(angles.dflns[choice])
                angles.dflns[choice].belong = s.accel.centralpos
                
                for j in range(fdirs.dflns_count):
                    if fdirs.dflns[j].belong == -1:
                        if fdirs.dflns[j].endpos >= s.accel.startpos and fdirs.dflns[j].startpos <= s.accel.endpos:
                            fdirs.dflns[j].belong = s.accel.centralpos
                            s.turns.append(fdirs.dflns[j])
                
                steps.append(s)
            
            for i in range(fdirs.dflns_count):
                
                if fdirs.dflns[i].belong != -1:
                    continue
                
                candidates = []
                scores = []
                for j in range(angles.dflns_count):
                    if angles.dflns[j].belong == -1:
                        if angles.dflns[j].endpos >= fdirs.dflns[i].startpos and angles.dflns[j].startpos <= fdirs.dflns[i].endpos:
                            candidates.append(j)
                            scores.append(abs(angles.dflns[j].centralpos - fdirs.dflns[i].centralpos))
                
                if len(candidates) == 0:
                    continue
                
                choice = candidates[scores.index(min(scores))]
                s = step()
                s.turns.append(fdirs.dflns[i])
                fdirs.dflns[i].belong = fdirs.dflns[i].centralpos
                s.bends.append(angles.dflns[choice])
                angles.dflns[choice].belong = s.turns[0].centralpos
                
                steps.append(s)
            
            steps_count = len(steps)
            for i in range(steps_count):
                if steps[i].accel != None:
                    steps[i].startpos = steps[i].accel.startpos
                    steps[i].coastpos = steps[i].accel.endpos
                else:
                    steps[i].startpos = steps[i].turns[0].startpos
                    steps[i].coastpos = steps[i].turns[0].endpos
                steps[i].centralpos = (steps[i].startpos + steps[i].coastpos) / 2
            steps.sort(key=lambda a: a.startpos)
            for i in range(steps_count - 1):
                steps[i].endpos = steps[i + 1].startpos - 1
            steps[steps_count - 1].endpos = l - 1
            
            for i in range(angles.dflns_count):
                if angles.dflns[i].belong == -1 and not angles.dflns[i].dict['recoil']:
                    candidates = []
                    scores = []
                    for j in range(steps_count):
                        if angles.dflns[i].endpos >= steps[j].startpos and angles.dflns[i].startpos <= steps[j].coastpos:
                            candidates.append(j)
                            scores.append(abs(angles.dflns[i].centralpos - steps[j].centralpos))
                    if len(candidates) == 0:
                        continue
                    choice = candidates[scores.index(min(scores))]
                    steps[choice].bends.append(angles.dflns[i])
                    angles.dflns[i].belong = steps[choice].centralpos
            
            for i in range(1, angles.dflns_count):
                if angles.dflns[i].belong == -1 and angles.dflns[i].dict['recoil']:
                    if angles.dflns[i - 1].belong != -1:
                        if angles.dflns[i - 1].endpos >= angles.dflns[i].startpos - 2:
                            choice = -1
                            for j in range(steps_count):
                                if steps[j].centralpos == angles.dflns[i - 1].belong:
                                    choice = j
                                    break
                            if choice == -1:
                                continue
                            steps[choice].bends.append(angles.dflns[i])
                            angles.dflns[i].belong = steps[choice].centralpos
            
            if settings['plot_figure']:
                fig, ax = plt.subplots() #step pairing graph
                speeds_scaled = [speed / fps for speed in speeds.list]
                turns_scaled = [turn / fps for turn in fdirs.dt_curve.list]
                ax.plot(speeds_scaled, 'c')
                ax.plot(turns_scaled, 'y')
                ax.plot(angles.list, 'm')
                i = 0
                colors = ['r', 'g', 'b']
                for s in steps:
                    c = colors[i]
                    i += 1
                    if i == 3:
                        i = 0
                    if s.accel != None:
                        plot_data(ax, speeds_scaled, s.startpos, s.coastpos + 1, c)
                    for turn in s.turns:
                        plot_data(ax, turns_scaled, turn.startpos, turn.endpos + 1, c)
                    for bend in s.bends:
                        plot_data(ax, angles.list, bend.startpos, bend.endpos + 1, c)
            
            for s in steps:
                
                s.properties.update({
                    'current_speed': cdist1s[round(s.centralpos)],
                    'step_length': sum(cen_dists[(s.startpos + 1):(s.endpos + 1)]),
                    'step_dur': (s.endpos + 1 - s.startpos) / fps})
                if s.accel != None:
                    s.properties.update({
                        'speed_change': s.accel.dict['speed_change'],
                        'accel': s.accel.dict['acceleration']})
                else:
                    s.properties.update({
                        'speed_change': 0,
                        'accel': 0})
                
                s.properties['coast_dur'] = max(0, s.endpos + 1 - s.coastpos) / fps
                s.properties['coast_percent'] = s.properties['coast_dur'] / s.properties['step_dur'] * 100
                
                s.turns_count = len(s.turns)
                s.bends_count = len(s.bends)
                s.properties['bend_count'] = s.bends_count
                
            for s in steps:
                
                startpos = round(max(0, s.startpos - fps / 2))
                endpos = round(min(l - 1, s.startpos + fps / 2))
                current_bend_count = 0
                for i in range(angles.dflns_count):
                    bend_startpos = angles.dflns[i].startpos
                    if bend_startpos >= startpos and bend_startpos <= endpos:
                        current_bend_count += 1
                s.properties['current_bend_s'] = current_bend_count / (endpos - startpos) * fps
                current_step_count = 0
                for i in range(steps_count):
                    if steps[i].startpos >= startpos and steps[i].startpos <= endpos:
                        current_step_count += 1
                s.properties['current_step_s'] = current_step_count / (endpos - startpos) * fps
                
                if s.turns_count >= 1:
                    
                    turns_durs = [turn.dict['turn_duration'] for turn in s.turns]
                    turns_angles = [turn.dict['turn_angle'] for turn in s.turns]
                    turns_angular_velocitys = [turn.dict['turn_angular_velocity'] for turn in s.turns]
                    turn_angle_overall = fdirs.list[s.turns[s.turns_count - 1].endpos] - fdirs.list[s.turns[0].startpos]
                    s.properties.update({'turn_angle': abs(turn_angle_overall)})
                    
                    if abs(turn_angle_overall) >= settings['min_turn_angle']:
                        if turn_angle_overall > settings['min_turn_angle']:
                            s.properties.update({'turn_laterality': 'right'})
                        elif turn_angle_overall < -settings['min_turn_angle']:
                            s.properties.update({'turn_laterality': 'left'})
                        s.properties.update({
                            'turn_dur': turns_durs[turns_angles.index(max(turns_angles))],
                            'turn_angular_velocity': turns_angular_velocitys[turns_angles.index(max(turns_angles))]})
                
                startpos = s.startpos
                coastpos = s.coastpos
                if s.accel != None and s.turns_count >= 1:
                    if abs(turn_angle_overall) >= settings['min_turn_angle']:
                        startpos = min(s.accel.startpos, s.turns[0].startpos)
                        coastpos = max(s.accel.endpos, s.turns[s.turns_count - 1].endpos)
                a = speeds.list[startpos]
                b = speeds.list[coastpos]
                if s.turns_count >= 1:
                    angle = abs(turn_angle_overall)
                else:
                    angle = 0
                s.properties.update({'velocity_change': sqrt(a ** 2 + b ** 2 - 2 * a * b * cos(angle))})
                
                if s.bends_count == 0:
                    
                    continue
                
                elif s.bends_count == 1:
                    
                    s.properties.update({
                        'bend_angle_reached': max(abs(s.bends[0].dict['angle start']), abs(s.bends[0].dict['angle end'])),
                        'bend_angle_traveled': s.bends[0].dict['angle_change'],
                        'bend_dur_total': s.bends[0].dict['bend_dur'],
                        'bend_angular_velocity': s.bends[0].dict['bend_angular_velocity'],
                        'bend_pos': s.bends[0].dict['bend_pos']})
                
                elif s.bends_count == 2:
                    
                    s.properties.update({
                        'bend_angle_reached': abs(s.bends[0].dict['angle end']),
                        'bend_angle_traveled': s.bends[0].dict['angle_change'] + s.bends[1].dict['angle_change'],
                        'bend_dur_total': s.bends[0].dict['bend_dur'] + s.bends[1].dict['bend_dur'],
                        'bend_angular_velocity': s.bends[0].dict['bend_angular_velocity'],
                        'bend_pos': s.bends[0].dict['bend_pos']})
                    if s.bends[0].dict['angle_change'] < s.bends[1].dict['angle_change']:
                        s.properties['max angle pos'] = 1
                
                elif s.bends_count >= 3:
                    
                    angles_reached = [s.bends[i].dict['angle end'] for i in range(s.bends_count - 1)]
                    angles_traveled = [s.bends[i].dict['angle_change'] for i in range(s.bends_count)]
                    angular_velocitys = [bend.dict['bend_angular_velocity'] for bend in s.bends]
                    durs = [bend.dict['bend_dur'] for bend in s.bends]
                    bend_pos = [s.bends[i].dict['bend_pos'] for i in range(s.bends_count)]
                    
                    angle_max = 0
                    angle_max_left = 0
                    angle_max_right = 0
                    for angle in angles_reached:
                        if angle > 0 and angle > angle_max_left:
                            angle_max_left = angle
                        elif angle < 0 and abs(angle) > angle_max_right:
                            angle_max_right = abs(angle)
                    if angle_max_left > angle_max_right + settings['min_bend_angle']:
                        angle_max = angle_max_left
                        angle_laterality = 'left'
                    elif angle_max_right > angle_max_left + settings['min_bend_angle']:
                        angle_max = angle_max_right
                        angle_laterality = 'right'
                    else:
                        angle_max = max(angle_max_left, angle_max_right)
                        angle_laterality = 'neutral'
                    max_angle_pos = [abs(angle) for angle in angles_reached].index(angle_max)
                    
                    s.properties.update({
                        'bend_angle_reached': angle_max,
                        'bend_angle_traveled': sum(angles_traveled),
                        'bend_dur_total': sum(durs),
                        'bend_angular_velocity': max(angular_velocitys),
                        'bend_pos': max(bend_pos),
                        'max angle pos': max_angle_pos})
                    
                s.properties.update({'bend_wave_freq': s.bends_count / s.properties['bend_dur_total']})
            
            steps_df = []
            for s in steps:
                temp = s.properties
                temp.update({'centralpos': s.centralpos})
                steps_df.append(temp)
            steps_df = pd.DataFrame(steps_df)
            steps_df = steps_df[steps_df['bend_count'] >= 1]
            steps_methods = {
                'step_length': agg2,
                'speed_change': agg1,
                'velocity_change': agg1,
                'accel': agg2,
                'current_speed': [],
                'step_dur': agg2,
                'coast_dur': agg1,
                'coast_percent': agg2,
                'current_step_s': agg3,
                'current_bend_s': agg3,
                'turn_angle': agg2,
                'turn_dur': agg2,
                'turn_angular_velocity': agg2,
                'bend_count': agg2,
                'bend_angle_reached': agg2,
                'bend_pos': agg2,
                'bend_angle_traveled': agg2,
                'bend_angular_velocity': agg2,
                'bend_dur_total': agg2,
                'bend_wave_freq': agg2}
            steps_DF = DF(steps_df, 'step', steps_methods.keys())
            steps_DF.dfs.update({
                'turn left': steps_df[steps_df['turn_laterality'] == 'left'],
                'turn right': steps_df[steps_df['turn_laterality'] == 'right'],
                'with turn': steps_df[steps_df['turn_laterality'] != 'neutral'],
                'without turn': steps_df[steps_df['turn_laterality'] == 'neutral'],})
            
            analysis_df.add(steps_DF.agg(steps_methods))
            analysis_df.add(steps_DF.agg(steps_methods, 'turn left'))
            analysis_df.add(steps_DF.agg(steps_methods, 'turn right'))
            analysis_df.add(steps_DF.agg(steps_methods, 'with turn'))
            analysis_df.add(steps_DF.agg(steps_methods, 'without turn'))
            
            for i in steps_methods:
                analysis_df.add(steps_DF.stratify1(i))
            for i in steps_methods:
                analysis_df.add(steps_DF.stratify2('turn left', 'turn right', i))
                analysis_df.add(steps_DF.stratify2('with turn', 'without turn', i))
            
            fdirs_df['video'] = videoname
            fdirs_all = pd.concat([fdirs_all, fdirs_df])
            angles_df['video'] = videoname
            angles_all = pd.concat([angles_all, angles_df])
            steps_df['video'] = videoname
            steps_all = pd.concat([steps_all, steps_df])
            
            print('Analysis of ' + videoname + ' complete.')
            analyses.append(analysis)
            
            if first_video:
                analyses_df = analysis_df.df[['Type', 'Classify', 'Stratify', 'Parameter', 'Method']]
                first_video = False
            analyses_df[videoname] = analysis_df.df['Value']
            
            with open(path + '/' + videoname + '_analysis_notes.csv', 'w') as f:
                for key in settings:
                    f.write(key + ', ' + str(settings[key]) + '\n')

        fdirs_all.to_csv('turns_all.csv', index=False)
        angles_all.to_csv('bends_all.csv', index=False)
        steps_all.to_csv('steps_all.csv', index=False)

        analyses = pd.DataFrame(analyses).T
        analyses = analyses.drop('videoname')
        analyses.columns = videonames
        analyses.to_csv('analyses.csv')
        
        with open('error2s.csv', 'w', newline='') as f:
            writer = csv.DictWriter(f, fieldnames=error2s_all[0].keys())
            writer.writeheader()
            writer.writerows(error2s_all)
        
        analyses_df.to_csv('analyses_df.csv', index=False)
        if not settings['spine_analysis']:
            from sys import exit
            exit()

        steps_all_adjusted = pd.DataFrame(steps_all)
        analyses_df_adjusted = pd.DataFrame(analyses_df)
        adjusts = ['current_speed', 'step_length', 'speed_change', 'velocity_change', 'accel']
        for videoname in videonames:
            fish_length = analyses.at['fish_length', videoname]
            steps_all_adjusted.loc[steps_all_adjusted['video'] == videoname, adjusts] = steps_all_adjusted.loc[steps_all_adjusted['video'] == videoname, adjusts].transform(lambda a: a / fish_length)
            analyses_df_adjusted.loc[analyses_df['Parameter'].isin(adjusts), videoname] = analyses_df_adjusted.loc[analyses_df['Parameter'].isin(adjusts), videoname].transform(lambda a: a / fish_length)
        steps_all_adjusted.to_csv('steps_all_adjusted.csv', index=False)
        analyses_df_adjusted.to_csv('analyses_df_adjusted.csv', index=False)
        print('All analyses complete.')

        with pd.ExcelWriter('properties.xlsx') as writer:
            for i in steps_all.columns:
                if i == 'video':
                    continue
                p = pd.DataFrame()
                for videoname in videonames:
                    p[videoname] = steps_all[steps_all['video'] == videoname][i]
                p.to_excel(writer, sheet_name=i, index=False)

        print('analysis finished.')
        
    else:
        break
